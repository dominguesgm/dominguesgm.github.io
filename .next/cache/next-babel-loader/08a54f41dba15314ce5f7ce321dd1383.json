{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { PerspectiveCamera } from 'three';\nconst cameraOptions = {\n  fov: 45,\n  near: 0.1,\n  far: 10000\n};\n\nclass Camera {\n  constructor() {\n    _defineProperty(this, \"instance\", null);\n\n    _defineProperty(this, \"zDepth\", void 0);\n\n    _defineProperty(this, \"updateZDepth\", () => {\n      const splitAngle = cameraOptions.fov / 2; // Use tangent formula to find adjacent side\n\n      this.zDepth = -window.innerHeight / (Math.abs(Math.tan(splitAngle * Math.PI / 180)) * 2);\n    });\n\n    _defineProperty(this, \"animate\", time => {\n      // Transition animation details\n      const startTime = 0;\n      const duration = 2000;\n      const finalTime = startTime + duration;\n      const finalYPosition = 0;\n      let finalZPosition = 0; // Entry transition\n\n      if (time < finalTime) {\n        const progress = Math.max((time - startTime) / duration, 0); // Translate along y axis\n\n        const distanceToCover = window.innerHeight; // Ease out quad formula\n        // const easingProgress =  progress * (2 - progress);\n        // Ease in out quad formula\n\n        const easingProgress = progress < .5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;\n        const position = distanceToCover - easingProgress * distanceToCover;\n        this.instance.position.y = position;\n        return {\n          isDone: false\n        };\n      } else {\n        const heightThreshold = window.innerHeight;\n        const scrollProgress = window.scrollY / heightThreshold;\n        finalZPosition = this.instance.position.z + (scrollProgress * this.zDepth - this.instance.position.z) * 0.1;\n      }\n\n      this.instance.position.y = finalYPosition;\n      this.instance.position.z = finalZPosition;\n      return {\n        isDone: true\n      };\n    });\n\n    _defineProperty(this, \"handleResize\", () => {\n      this.instance.aspect = window.innerWidth / window.innerHeight;\n      this.instance.updateProjectionMatrix();\n      this.updateZDepth();\n    });\n\n    this.instance = new PerspectiveCamera(cameraOptions.fov, window.innerWidth / window.innerHeight, cameraOptions.near, cameraOptions.far);\n    this.updateZDepth();\n  }\n\n}\n\nexport default Camera;","map":{"version":3,"sources":["/Users/gil/Projects/dominguesgm.github.io/src/shared/components/canvas/components/camera/Camera.js"],"names":["PerspectiveCamera","cameraOptions","fov","near","far","Camera","constructor","splitAngle","zDepth","window","innerHeight","Math","abs","tan","PI","time","startTime","duration","finalTime","finalYPosition","finalZPosition","progress","max","distanceToCover","easingProgress","position","instance","y","isDone","heightThreshold","scrollProgress","scrollY","z","aspect","innerWidth","updateProjectionMatrix","updateZDepth"],"mappings":";;AAAA,SACCA,iBADD,QAEO,OAFP;AAIA,MAAMC,aAAa,GAAG;AACrBC,EAAAA,GAAG,EAAE,EADgB;AAErBC,EAAAA,IAAI,EAAE,GAFe;AAGrBC,EAAAA,GAAG,EAAE;AAHgB,CAAtB;;AAMA,MAAMC,MAAN,CAAa;AAIZC,EAAAA,WAAW,GAAG;AAAA,sCAHH,IAGG;;AAAA;;AAAA,0CAWC,MAAM;AACpB,YAAMC,UAAU,GAAGN,aAAa,CAACC,GAAd,GAAkB,CAArC,CADoB,CAGpB;;AACA,WAAKM,MAAL,GAAc,CAAEC,MAAM,CAACC,WAAT,IAAyBC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAASN,UAAU,GAACI,IAAI,CAACG,EAAhB,GAAmB,GAA5B,CAAT,IAA6C,CAAtE,CAAd;AACA,KAhBa;;AAAA,qCAkBHC,IAAD,IAAU;AAEnB;AACA,YAAMC,SAAS,GAAG,CAAlB;AACA,YAAMC,QAAQ,GAAG,IAAjB;AACA,YAAMC,SAAS,GAAGF,SAAS,GAAGC,QAA9B;AACA,YAAME,cAAc,GAAG,CAAvB;AACA,UAAIC,cAAc,GAAG,CAArB,CAPmB,CASnB;;AACA,UAAGL,IAAI,GAAGG,SAAV,EAAqB;AACpB,cAAMG,QAAQ,GAAGV,IAAI,CAACW,GAAL,CAAU,CAACP,IAAI,GAAGC,SAAR,IAAqBC,QAA/B,EAA0C,CAA1C,CAAjB,CADoB,CAGpB;;AACA,cAAMM,eAAe,GAAGd,MAAM,CAACC,WAA/B,CAJoB,CAMpB;AACA;AACA;;AACA,cAAMc,cAAc,GAAGH,QAAQ,GAAG,EAAX,GACtB,IAAIA,QAAJ,GAAeA,QADO,GAEtB,CAAC,CAAD,GAAK,CAAC,IAAI,IAAIA,QAAT,IAAqBA,QAF3B;AAIA,cAAMI,QAAQ,GAAGF,eAAe,GAAGC,cAAc,GAAGD,eAApD;AACA,aAAKG,QAAL,CAAcD,QAAd,CAAuBE,CAAvB,GAA2BF,QAA3B;AAEA,eAAO;AACNG,UAAAA,MAAM,EAAE;AADF,SAAP;AAGA,OAnBD,MAmBO;AACN,cAAMC,eAAe,GAAGpB,MAAM,CAACC,WAA/B;AACA,cAAMoB,cAAc,GAAGrB,MAAM,CAACsB,OAAP,GAAiBF,eAAxC;AACAT,QAAAA,cAAc,GAAG,KAAKM,QAAL,CAAcD,QAAd,CAAuBO,CAAvB,GAA2B,CAACF,cAAc,GAAG,KAAKtB,MAAtB,GAA+B,KAAKkB,QAAL,CAAcD,QAAd,CAAuBO,CAAvD,IAA4D,GAAxG;AACA;;AAED,WAAKN,QAAL,CAAcD,QAAd,CAAuBE,CAAvB,GAA2BR,cAA3B;AACA,WAAKO,QAAL,CAAcD,QAAd,CAAuBO,CAAvB,GAA2BZ,cAA3B;AAEA,aAAO;AACNQ,QAAAA,MAAM,EAAE;AADF,OAAP;AAGA,KA3Da;;AAAA,0CA6DC,MAAM;AACpB,WAAKF,QAAL,CAAcO,MAAd,GAAuBxB,MAAM,CAACyB,UAAP,GAAoBzB,MAAM,CAACC,WAAlD;AACA,WAAKgB,QAAL,CAAcS,sBAAd;AACA,WAAKC,YAAL;AACA,KAjEa;;AACb,SAAKV,QAAL,GAAgB,IAAI1B,iBAAJ,CACfC,aAAa,CAACC,GADC,EAEfO,MAAM,CAACyB,UAAP,GAAoBzB,MAAM,CAACC,WAFZ,EAGfT,aAAa,CAACE,IAHC,EAIfF,aAAa,CAACG,GAJC,CAAhB;AAOA,SAAKgC,YAAL;AACA;;AAbW;;AAwEb,eAAe/B,MAAf","sourcesContent":["import {\n\tPerspectiveCamera,\n} from 'three';\n\nconst cameraOptions = {\n\tfov: 45,\n\tnear: 0.1,\n\tfar: 10000,\n};\n\nclass Camera {\n\tinstance = null;\n\tzDepth;\n\n\tconstructor() {\n\t\tthis.instance = new PerspectiveCamera(\n\t\t\tcameraOptions.fov,\n\t\t\twindow.innerWidth / window.innerHeight,\n\t\t\tcameraOptions.near,\n\t\t\tcameraOptions.far\n\t\t);\n\n\t\tthis.updateZDepth();\n\t}\n\n\tupdateZDepth = () => {\n\t\tconst splitAngle = cameraOptions.fov/2;\n\n\t\t// Use tangent formula to find adjacent side\n\t\tthis.zDepth = -(window.innerHeight) / (Math.abs(Math.tan(splitAngle*Math.PI/180)) * 2);\n\t};\n\n\tanimate = (time) => {\n\n\t\t// Transition animation details\n\t\tconst startTime = 0;\n\t\tconst duration = 2000;\n\t\tconst finalTime = startTime + duration;\n\t\tconst finalYPosition = 0;\n\t\tlet finalZPosition = 0;\n\n\t\t// Entry transition\n\t\tif(time < finalTime) {\n\t\t\tconst progress = Math.max(((time - startTime) / duration), 0);\n\n\t\t\t// Translate along y axis\n\t\t\tconst distanceToCover = window.innerHeight;\n\n\t\t\t// Ease out quad formula\n\t\t\t// const easingProgress =  progress * (2 - progress);\n\t\t\t// Ease in out quad formula\n\t\t\tconst easingProgress = progress < .5 ?\n\t\t\t\t2 * progress * progress :\n\t\t\t\t-1 + (4 - 2 * progress) * progress;\n\n\t\t\tconst position = distanceToCover - easingProgress * distanceToCover;\n\t\t\tthis.instance.position.y = position;\n\n\t\t\treturn {\n\t\t\t\tisDone: false,\n\t\t\t};\n\t\t} else {\n\t\t\tconst heightThreshold = window.innerHeight;\n\t\t\tconst scrollProgress = window.scrollY / heightThreshold;\n\t\t\tfinalZPosition = this.instance.position.z + (scrollProgress * this.zDepth - this.instance.position.z) * 0.1;\n\t\t}\n\n\t\tthis.instance.position.y = finalYPosition;\n\t\tthis.instance.position.z = finalZPosition;\n\n\t\treturn {\n\t\t\tisDone: true,\n\t\t};\n\t}\n\n\thandleResize = () => {\n\t\tthis.instance.aspect = window.innerWidth / window.innerHeight;\n\t\tthis.instance.updateProjectionMatrix();\n\t\tthis.updateZDepth();\n\t}\n}\n\nexport default Camera;\n"]},"metadata":{},"sourceType":"module"}